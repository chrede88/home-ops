# Flux

The next thing to setup is [Fluxcd](https://fluxcd.io) or just Flux for short. By running Flux my git repository becomes the source of truth for my Kubernetes cluster. Any changes made to the manifests in the git repository is automatically reflected in the cluster. Pairing Flux with Renovate is a potent combi that makes it easy to keep everything up-to-date, see [renovate.md](./renovate.md) for more info.

## Moving to the Flux Operator
I recently moved to the flux operator. Most of the following is still useful information. The old way of bootstrapping Flux is no longer valid. You still need to setup Sops/Age if you want to store secrets in your git repository, so that section is still valid. The stuff about notification and alerts are also still valid.

See the [Flux operator docs](https://fluxcd.control-plane.io/operator/install/) for installing the Flux operator in a fresh cluster.

I've documented my migration process [here](./flux-operator.md)

## Setting up Flux
I'll use a ssh key to authenticate with Github. So first item on the agenda is to generate a ssh key for Flux.

```zsh
ssh-keygen -t ed25519 -C "christian@cjsolsen.com"
```

Next I'll add the public key to the deploy keys in my Github repository (the key needs push access).

Now I'm ready to bootstrap Flux ðŸŽ‰

But first, let's use Flux to check if everything will work before running the real bootstrap.

```zsh
flux check --pre
```

### Bootstrapping with excisting git repo
I'm bootstrapping using a git repo that already contain yaml manifests that are encrypted with Sops/Age. This means I have a to add the encryption secret to the cluster before bootstrapping Flux!

The namespace doesn't excist, so first I need to create that.

```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: flux-system
```

See section on [Sops/Age](#sops--age).

## Bootstrap

Start the bootstrap when everything is good.

```zsh
flux bootstrap git \
  --url=ssh://git@github.com/chrede88/home-ops \
  --interval 30m \
  --branch=main \
  --private-key-file=/Users/cjso/.ssh/flux-key \
  --path=cluster/kubernetes
```

Flux will now install all the needed resources in a seperate namespace called `flux-system`.

It's a good idea to rotate the used authentication keys on a regular basis. This can be done with Flux.
1) Delete the secret in the `flux-system` namespace
2) Run the following command:
```zsh
flux create secret git flux-system \
  --url=ssh://git@github.com/chrede88/home-ops \
  --ssh-key-algorithm=ed25519
```
Remember to update the key on Github as well.

## SOPS & age
As the plan is publish everything about my cluster on Github, I need to encrypt the Kubernetes secrets. Even if one chooses a private Github repo I would still do it, just to be on the safe side.

First I've to install SOPS and age.
```zsh
brew install sops age
```

Next generate an age key to use for encryption/decryption:

```zsh
age-keygen -o flux.agekey
```

The key is stored in `~/.config/sops/age/flux.agekey`.
SOPS will look for private keys in `~/.config/sops/age/keys.txt`. Place all your private keys in this file.
In order for Flux to be able to decrypt files we need to add a Kubernetes secret with the age key.

```zsh
cat flux.agekey |
kubectl create secret generic sops-age \
--namespace=flux-system \
--from-file=flux.agekey=/dev/stdin
```
Before encrypting this file, I'll setup a SOPS config file, so I don't have to apply the age public key everytime. I've to add a file called `.sops.yaml` to the root of my repository, with the following content:

```yaml
creation_rules:
  - path_regex: cluster/talos/.*.ya?ml # Talos config
    input_type: yaml
    encrypted_regex: ^(token|crt|key|id|secret|secrets|secretboxEncryptionSecret|ca)$
    age: <age-public-key>
  - path_regex: cluster/kubernetes/.*.ya?ml # Kubernetes secrets
    input_type: yaml
    encrypted_regex: ^(data|stringData)$
    age: <age-public-key>
```

I would like to store the secret manifest in a yaml file so I can easily find it. We can retreive the secret using `kubectl`:

```zsh
kubectl get secret sops-age -n flux-system -o yaml > flux-system/config/sops-age.yaml
```

With the SOPS config file in the root of the repository I can now very easily encrypt the kubernetes secret I just created:

```zsh
sops -e -i sops-age.yaml
```

The `-e` flag means encrypt and `-i` means "in place". Use `-d` to decrypt a file.

### Patch gotk-sync.yaml
The last thing I need to do is to patch the autogenerated main cluster kustomization, by adding the following yaml to the `spec` field.

```yaml
decryption:
  provider: sops
  secretRef:
    name: sops-age
```

This tells Flux to look in the `sops-age` secret for the decryption key.

## Setup Notifications/Alerts
Flux can push notification/alerts to a long list of different platforms. I'll setup a [Slack bot](https://api.slack.com/start/quickstart#creating) called `Flux`. Very original, I know...

I need the bot token so I can create a Kubernetes secret, as well as a flux notification provider and a Flux alert.
I'll add these files to each namespace I'll create, so Flux can send alerts for all reconciliation errors.

```yaml
# notifications.yaml
---
apiVersion: notification.toolkit.fluxcd.io/v1beta3
kind: Provider
metadata:
  name: slack-bot
  namespace: <namespace>
spec:
  type: slack
  channel: flux-cd
  address: https://slack.com/api/chat.postMessage
  secretRef:
    name: slack-token
---
apiVersion: notification.toolkit.fluxcd.io/v1beta3
kind: Alert
metadata:
  name: slack
  namespace: <namespace>
spec:
  providerRef:
    name: slack-bot
  eventSeverity: error
  eventSources:
    - kind: GitRepository
      name: "*"
    - kind: HelmRelease
      name: "*"
    - kind: HelmRepository
      name: "*"
    - kind: Kustomization
      name: "*"
---
apiVersion: v1
kind: Secret
metadata:
  name: slack-token
  namespace: <namespace>
stringData:
  token: <bot-token>
```

The kustomization also have to be updated so Flux knows about these new files.

```yaml
# kustomization.yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization
resources:
- gotk-components.yaml
- gotk-sync.yaml
- notifications.yaml # <- new
```

And remember to encrypt the secret before pushing to github.

You can check that the alerts were setup correctly by executing:

```zsh
flux get alerts
```

The Flux CLI tools defaults to the `flux-system` namepace. To check for other namespaces use the standard `-n` flag or `-A` for all namespaces.

## General notes on Kustomization
Kustomizations are great and I rely heavily on them for my Flux setup. It's a great way to tell Flux what to look for.
Flux sets up a `GitRepository` and a main Kustomziation at bootstrap. These are located in `./kubernetes/flux-system/gotk-sync.yaml`.
The Kustomization defines the general path `./cluster/kubernetes`, so all Kustomizations on this path (including subpaths) are automatically found.

My general repository layout is by namespace. So I'll have a folder for each namespace on my cluster. I do however have one extra folder called `flux-resources`. Here I declare the Helm repositories etc. that I use to install stuff. I like to keep them all in one place, so they are easy to find.

Within each namespace folder I'll have the following general layout (I'll use kube-system as an example):

```yaml
# ./cluster/kubernetes/kube-system/kustomization.yaml
---
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization
resources:
  # Pre Flux-Kustomizations
  - ./namespace.yaml
  - ./slack-token.yaml # <- for notifications
  - ./notifications.yaml
  # Flux-Kustomizations
  - ./cilium/ks.yaml # <- new folder for each app in the namespace
```

```yaml
# # ./cluster/kubernetes/kube-system/namespace.yaml
---
apiVersion: v1
kind: Namespace
metadata:
  name: kube-system
  annotations:
    kustomize.toolkit.fluxcd.io/prune: disabled # <- don't delete stuff in this namespace
```

For each app I'll have a file that points to the folder containing the helm release or normal Kubernetes manifest files.

```yaml
# ./cluster/kubernetes/kube-system/cilium/ks.yaml
---
apiVersion: kustomize.toolkit.fluxcd.io/v1
kind: Kustomization
metadata:
  name: cilium
  namespace: flux-system
spec:
  targetNamespace: kube-system
  commonMetadata:
    labels:
      app.kubernetes.io/name: cilium
  path: ./kubernetes/kube-system/cilium/app
  prune: false # should never be deleted
  sourceRef:
    kind: GitRepository
    name: flux-system
  wait: false
  interval: 30m
  retryInterval: 1m
  timeout: 5m
```

And within `./kubernetes/kube-system/cilium/app` the last Kustomization file:

```yaml
# # ./cluster/kubernetes/kube-system/cilium/app/kustomization.yaml
---
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization
resources:
  - ./helmrelease.yaml
```

### Hang on - Are there two types of Kostomizations
Yes! Which is a bit unfortunate. It took me a bit to figure out what the difference is and when to use what. In short you can think of the `kustomize.config.k8s.io/v1beta1` kind as a pointer to resources, while the `kustomize.toolkit.fluxcd.io/v1` kind defines a (for lack of a better name) Kustomization, that controls how often flux checks for changes and if it depends on other Kustomizations to reconcile before it starts reconciling, etc. See the [fluxcd docs](https://fluxcd.io/flux/faq/#are-there-two-kustomization-types) for an example.